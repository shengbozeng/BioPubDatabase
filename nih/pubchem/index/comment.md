# 为什么不用 SQLite（以及什么时候 SQLite 反而更合适）

需求里有一条“硬得像石头”的约束——**一次批量查找可能几十万甚至几十万+，且希望每个 key 的查找成本近似常数**。这会把“SQL 数据库那套模型”的弱点放大得很明显。


## 1) 你的查询形态是“吞吐型批量查”，不是“复杂条件查”

SQLite 的优势是：

* 结构化表、复杂 JOIN、范围过滤、聚合、SQL 生态成熟

但你现在要的是：

* `key -> (file, start, end)` 这种“字典式定位”
* key 规模可到几十万、甚至更多
* 查出来后通常要继续去原文件按 offset 取文本段

这非常接近 **KV（Key-Value）数据库的天然应用场景**：**大量随机点查** + 极少的复杂过滤。

## 2) SQLite 的“批量 IN 查询”会在工程层面踩雷

你可能会想到：

```sql
SELECT ... FROM records WHERE cid IN (....几十万个....);
```

问题是：

* SQL 解析和编译成本会飙升
* 参数绑定数量巨大（SQLite 默认也有参数数目限制，需要改编译选项或拆分）
* 即使拆分成多次查询，仍然会有大量 SQL 执行开销（prepare/step/finalize）
* 并发读很强，但你最终会被“SQL 层的管理开销”吃掉不少吞吐

## 3) “近似常数查找”的诉求更贴近 KV（尤其是 LMDB）

严格说 SQLite B-Tree 是 `O(logN)`；LMDB 内部也是 B+Tree，但 **LMDB 的读路径更接近 mmap + 最少抽象层开销**，工程上表现出来就是：

* 单 key `get()` 极快、每次开销稳定
* 批量几十万 key 也就是几十万次 `get()`（均摊成本近似常数）
* 没有 SQL 解析、没有执行计划、没有返回行对象那一套额外成本

## 4) 你还需要“一对多”关系：CID -> N 个 conformers

SQLite 可以用 join 表解决，但当 N 很大时：

* 你还是要拉出巨量结果集
* 结果集的对象化/序列化/传输开销不小

LMDB 这边用 **posting list 分页块**：

* `CID -> pages -> [ALID...]`
* 读取时流式迭代页面
  很符合你“可能几十万 conformers”的现实。

## 5) SQLite 什么时候更适合你？

如果未来你要加这些需求：

* 按多个字段组合过滤（比如 modelid + date + cid 范围）
* 做统计聚合（count/group by）
* 做全文检索（FTS）
* 需要可视化工具直接打开查询

那 SQLite 更舒服。
甚至你可以做一个**混合架构**：
LMDB 专门负责 “key -> offset”，SQLite/Parquet 负责“分析型查询”。两者不冲突。

---
